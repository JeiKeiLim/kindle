<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>kindle.generator API documentation</title>
<meta name="description" content="PyTorch Module Generator for parsing model yaml file …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kindle.generator</code></h1>
</header>
<section id="section-intro">
<p>PyTorch Module Generator for parsing model yaml file.</p>
<ul>
<li>Author: Jongkuk Lim</li>
<li>Contact: lim.jeikei@gmail.com</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;PyTorch Module Generator for parsing model yaml file.

- Author: Jongkuk Lim
- Contact: lim.jeikei@gmail.com
&#34;&#34;&#34;

from kindle.generator.base_generator import GeneratorAbstract, ModuleGenerator
from kindle.generator.bottleneck import BottleneckGenerator
from kindle.generator.concat import ConcatGenerator
from kindle.generator.conv import ConvGenerator
from kindle.generator.dwconv import DWConvGenerator
from kindle.generator.flatten import FlattenGenerator
from kindle.generator.linear import LinearGenerator
from kindle.generator.poolings import (AvgPoolGenerator,
                                       GlobalAvgPoolGenerator,
                                       MaxPoolGenerator)

__all__ = [
    &#34;ModuleGenerator&#34;,
    &#34;GeneratorAbstract&#34;,
    &#34;BottleneckGenerator&#34;,
    &#34;ConcatGenerator&#34;,
    &#34;ConvGenerator&#34;,
    &#34;DWConvGenerator&#34;,
    &#34;FlattenGenerator&#34;,
    &#34;LinearGenerator&#34;,
    &#34;AvgPoolGenerator&#34;,
    &#34;GlobalAvgPoolGenerator&#34;,
    &#34;MaxPoolGenerator&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="kindle.generator.base_generator" href="base_generator.html">kindle.generator.base_generator</a></code></dt>
<dd>
<div class="desc"><p>Base Module Generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.bottleneck" href="bottleneck.html">kindle.generator.bottleneck</a></code></dt>
<dd>
<div class="desc"><p>Bottleneck module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.concat" href="concat.html">kindle.generator.concat</a></code></dt>
<dd>
<div class="desc"><p>Concat module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.conv" href="conv.html">kindle.generator.conv</a></code></dt>
<dd>
<div class="desc"><p>Conv module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.dwconv" href="dwconv.html">kindle.generator.dwconv</a></code></dt>
<dd>
<div class="desc"><p>DWConv module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.flatten" href="flatten.html">kindle.generator.flatten</a></code></dt>
<dd>
<div class="desc"><p>Flatten module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.linear" href="linear.html">kindle.generator.linear</a></code></dt>
<dd>
<div class="desc"><p>Linear module generator …</p></div>
</dd>
<dt><code class="name"><a title="kindle.generator.poolings" href="poolings.html">kindle.generator.poolings</a></code></dt>
<dd>
<div class="desc"><p>MaxPool, AvgPool, and GlobalAvgPool modules generator …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kindle.generator.AvgPoolGenerator"><code class="flex name class">
<span>class <span class="ident">AvgPoolGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Average pooling module generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AvgPoolGenerator(MaxPoolGenerator):
    &#34;&#34;&#34;Average pooling module generator.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.poolings.MaxPoolGenerator" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator">MaxPoolGenerator</a></li>
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.AvgPoolGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.poolings.MaxPoolGenerator" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator">MaxPoolGenerator</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.poolings.MaxPoolGenerator.base_module" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator.base_module">base_module</a></code></li>
<li><code><a title="kindle.generator.poolings.MaxPoolGenerator.compute_out_shape" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.poolings.MaxPoolGenerator.in_channel" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.poolings.MaxPoolGenerator.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
<li><code><a title="kindle.generator.poolings.MaxPoolGenerator.out_channel" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.BottleneckGenerator"><code class="flex name class">
<span>class <span class="ident">BottleneckGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottleneck block generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BottleneckGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Bottleneck block generator.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        return self._get_divisible_channel(self.args[0] * self.width_multiply)

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
        return self.in_channels[self.from_idx]  # type: ignore

    @property
    def base_module(self) -&gt; nn.Module:
        &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
        return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)

    def compute_out_shape(
        self, size: Union[list, np.ndarray], repeat: int = 1
    ) -&gt; List[int]:
        &#34;&#34;&#34;Compute output shape.&#34;&#34;&#34;
        with torch.no_grad():
            module: nn.Module = self(repeat=repeat)
            module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
            return list(module_out.shape[-3:])

    def __call__(self, repeat: int = 1):
        args = [self.in_channel, self.out_channel, *self.args[1:]]
        module = self.base_module(*args)
        return self._get_module(module)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.BottleneckGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.BottleneckGenerator.base_module"><code class="name">var <span class="ident">base_module</span> : torch.nn.modules.module.Module</code></dt>
<dd>
<div class="desc"><p>Returns module class from kindle.common_modules based on the class name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_module(self) -&gt; nn.Module:
    &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
    return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)</code></pre>
</details>
</dd>
<dt id="kindle.generator.BottleneckGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
<dt id="kindle.generator.BottleneckGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    return self._get_divisible_channel(self.args[0] * self.width_multiply)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.BottleneckGenerator.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: Union[list, numpy.ndarray], repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute output shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_out_shape(
    self, size: Union[list, np.ndarray], repeat: int = 1
) -&gt; List[int]:
    &#34;&#34;&#34;Compute output shape.&#34;&#34;&#34;
    with torch.no_grad():
        module: nn.Module = self(repeat=repeat)
        module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
        return list(module_out.shape[-3:])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.ConcatGenerator"><code class="flex name class">
<span>class <span class="ident">ConcatGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenation module generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConcatGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Concatenation module generator.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
        # error: Item &#34;int&#34; of &#34;Union[int, List[int]]&#34; has no attribute
        # &#34;__iter__&#34; (not iterable)
        return sum([self.in_channels[i] for i in self.from_idx])  # type: ignore

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        return -1

    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
        return [self.out_channel] + list(size[0][1:])

    def __call__(self, repeat: int = 1):
        module = Concat(*self.args)

        return self._get_module(module)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.ConcatGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.ConcatGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    return -1</code></pre>
</details>
</dd>
<dt id="kindle.generator.ConcatGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
    # error: Item &#34;int&#34; of &#34;Union[int, List[int]]&#34; has no attribute
    # &#34;__iter__&#34; (not iterable)
    return sum([self.in_channels[i] for i in self.from_idx])  # type: ignore</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.ConcatGenerator.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: numpy.ndarray, repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute out shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
    &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
    return [self.out_channel] + list(size[0][1:])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.ConvGenerator"><code class="flex name class">
<span>class <span class="ident">ConvGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Conv2d generator for parsing module.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Conv2d generator for parsing module.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        return self._get_divisible_channel(self.args[0] * self.width_multiply)

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
        return self.in_channels[self.from_idx]  # type: ignore

    @property
    def base_module(self) -&gt; nn.Module:
        &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
        return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)

    @torch.no_grad()
    def compute_out_shape(
        self, size: Union[list, np.ndarray], repeat: int = 1
    ) -&gt; List[int]:
        module: nn.Module = self(repeat=repeat)
        module.eval()
        module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
        return list(module_out.shape[-3:])

    def __call__(self, repeat: int = 1):
        args = [self.in_channel, self.out_channel, *self.args[1:]]
        if repeat &gt; 1:
            stride = 1
            # Important!: stride only applies at the end of the repeat.
            if len(args) &gt; 2:
                stride = args[3]
                args[3] = 1

            module = []
            for i in range(repeat):
                if len(args) &gt; 1 and stride &gt; 1 and i == repeat - 1:
                    args[3] = stride

                module.append(self.base_module(*args))
                args[0] = self.out_channel
        else:
            module = self.base_module(*args)

        return self._get_module(module)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.ConvGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.ConvGenerator.base_module"><code class="name">var <span class="ident">base_module</span> : torch.nn.modules.module.Module</code></dt>
<dd>
<div class="desc"><p>Returns module class from kindle.common_modules based on the class name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_module(self) -&gt; nn.Module:
    &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
    return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)</code></pre>
</details>
</dd>
<dt id="kindle.generator.ConvGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
<dt id="kindle.generator.ConvGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    return self._get_divisible_channel(self.args[0] * self.width_multiply)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.compute_out_shape" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.DWConvGenerator"><code class="flex name class">
<span>class <span class="ident">DWConvGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Depth-wise convolution generator for parsing module.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DWConvGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Depth-wise convolution generator for parsing module.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        return self._get_divisible_channel(self.args[0] * self.width_multiply)

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
        return self.in_channels[self.from_idx]  # type: ignore

    @property
    def base_module(self) -&gt; nn.Module:
        &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
        return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)

    @torch.no_grad()
    def compute_out_shape(
        self, size: Union[list, np.ndarray], repeat: int = 1
    ) -&gt; List[int]:
        module: nn.Module = self(repeat=repeat)
        module.eval()
        module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
        return list(module_out.shape[-3:])

    def __call__(self, repeat: int = 1):
        args = [self.in_channel, self.out_channel, *self.args[1:]]
        if repeat &gt; 1:
            stride = 1
            # Important!: stride only applies at the end of the repeat.
            if len(args) &gt; 2:
                stride = args[3]
                args[3] = 1

            module = []
            for i in range(repeat):
                if len(args) &gt; 1 and stride &gt; 1 and i == repeat - 1:
                    args[3] = stride

                module.append(self.base_module(*args))
                args[0] = self.out_channel
        else:
            module = self.base_module(*args)

        return self._get_module(module)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.DWConvGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.DWConvGenerator.base_module"><code class="name">var <span class="ident">base_module</span> : torch.nn.modules.module.Module</code></dt>
<dd>
<div class="desc"><p>Returns module class from kindle.common_modules based on the class name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_module(self) -&gt; nn.Module:
    &#34;&#34;&#34;Returns module class from kindle.common_modules based on the class name.&#34;&#34;&#34;
    return getattr(__import__(&#34;kindle.modules&#34;, fromlist=[&#34;&#34;]), self.name)</code></pre>
</details>
</dd>
<dt id="kindle.generator.DWConvGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
<dt id="kindle.generator.DWConvGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    return self._get_divisible_channel(self.args[0] * self.width_multiply)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.compute_out_shape" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.FlattenGenerator"><code class="flex name class">
<span>class <span class="ident">FlattenGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Flatten module generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlattenGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Flatten module generator.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        return math.prod(self.args)

    @property
    def in_channel(self) -&gt; int:

        return -1

    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        return [self.out_channel]

    def __call__(self, repeat: int = 1):
        return self._get_module(nn.Flatten())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.FlattenGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.compute_out_shape" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.in_channel" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.out_channel" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.out_channel">out_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.GeneratorAbstract"><code class="flex name class">
<span>class <span class="ident">GeneratorAbstract</span></span>
<span>(</span><span>*args, from_idx: Union[int, List[int]] = -1, in_channels: Tuple[int] = (0,), width_multiply: float = 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Module Generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneratorAbstract(ABC):
    &#34;&#34;&#34;Abstract Module Generator.&#34;&#34;&#34;

    CHANNEL_DIVISOR: int = 8

    def __init__(
        self,
        *args,
        from_idx: Union[int, List[int]] = -1,
        in_channels: Tuple[int] = (0,),
        width_multiply: float = 1.0,
    ):
        &#34;&#34;&#34;Initialize module generator.

        Args:
            *args: Module arguments
            from_idx: Module input index
            in_channels: Number of input channel
            width_multiply: Channel width multiply
        &#34;&#34;&#34;
        self.args = tuple(args)
        self.from_idx = from_idx
        self.in_channels = in_channels
        self.width_multiply = width_multiply

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Module name.&#34;&#34;&#34;
        return self.__class__.__name__.replace(&#34;Generator&#34;, &#34;&#34;)

    def _get_module(self, module: Union[nn.Module, List[nn.Module]]) -&gt; nn.Module:
        &#34;&#34;&#34;Get module from __call__ function.&#34;&#34;&#34;
        if isinstance(module, list):
            module = nn.Sequential(*module)

        # error: Incompatible types in assignment (expression has type &#34;Union[Tensor, Module, int]&#34;,
        # variable has type &#34;Union[Tensor, Module]&#34;)
        # error: List comprehension has incompatible type List[int];
        # expected List[Union[Tensor, Module]]
        module.n_params = sum([x.numel() for x in module.parameters()])  # type: ignore
        # error: Cannot assign to a method
        module.type = self.name  # type: ignore

        return module

    @classmethod
    def _get_divisible_channel(cls, n_channel: int) -&gt; int:
        &#34;&#34;&#34;Get divisible channel by default divisor.

        Args:
            n_channel: number of channel.

        Returns:
            Ex) given {n_channel} is 52 and {GeneratorAbstract.CHANNEL_DIVISOR} is 8.,
                return channel is 56 since ceil(52/8) = 7 and 7*8 = 56
        &#34;&#34;&#34;
        return make_divisible(n_channel, divisor=cls.CHANNEL_DIVISOR)

    @property
    @abstractmethod
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Out channel of the module.&#34;&#34;&#34;

    @property
    @abstractmethod
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;In channel of the module.&#34;&#34;&#34;

    @abstractmethod
    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        &#34;&#34;&#34;Compute output shape when {size} is given.

        Args: input size to compute output shape.
        &#34;&#34;&#34;

    @abstractmethod
    def __call__(self, repeat: int = 1):
        &#34;&#34;&#34;Returns nn.Module component.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="kindle.generator.bottleneck.BottleneckGenerator" href="bottleneck.html#kindle.generator.bottleneck.BottleneckGenerator">BottleneckGenerator</a></li>
<li><a title="kindle.generator.concat.ConcatGenerator" href="concat.html#kindle.generator.concat.ConcatGenerator">ConcatGenerator</a></li>
<li><a title="kindle.generator.conv.ConvGenerator" href="conv.html#kindle.generator.conv.ConvGenerator">ConvGenerator</a></li>
<li><a title="kindle.generator.dwconv.DWConvGenerator" href="dwconv.html#kindle.generator.dwconv.DWConvGenerator">DWConvGenerator</a></li>
<li><a title="kindle.generator.flatten.FlattenGenerator" href="flatten.html#kindle.generator.flatten.FlattenGenerator">FlattenGenerator</a></li>
<li><a title="kindle.generator.linear.LinearGenerator" href="linear.html#kindle.generator.linear.LinearGenerator">LinearGenerator</a></li>
<li><a title="kindle.generator.poolings.GlobalAvgPoolGenerator" href="poolings.html#kindle.generator.poolings.GlobalAvgPoolGenerator">GlobalAvgPoolGenerator</a></li>
<li><a title="kindle.generator.poolings.MaxPoolGenerator" href="poolings.html#kindle.generator.poolings.MaxPoolGenerator">MaxPoolGenerator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.GeneratorAbstract.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.GeneratorAbstract.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>In channel of the module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;In channel of the module.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="kindle.generator.GeneratorAbstract.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Module name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Module name.&#34;&#34;&#34;
    return self.__class__.__name__.replace(&#34;Generator&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="kindle.generator.GeneratorAbstract.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Out channel of the module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Out channel of the module.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.GeneratorAbstract.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: numpy.ndarray, repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute output shape when {size} is given.</p>
<p>Args: input size to compute output shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
    &#34;&#34;&#34;Compute output shape when {size} is given.

    Args: input size to compute output shape.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="kindle.generator.GlobalAvgPoolGenerator"><code class="flex name class">
<span>class <span class="ident">GlobalAvgPoolGenerator</span></span>
<span>(</span><span>*args, from_idx: Union[int, List[int]] = -1, in_channels: Tuple[int] = (0,), width_multiply: float = 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Global average pooling module generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobalAvgPoolGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Global average pooling module generator.&#34;&#34;&#34;

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        if isinstance(self.from_idx, int):
            return self.in_channels[self.from_idx]

        raise Exception()

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        if isinstance(self.from_idx, int):
            return self.in_channels[self.from_idx]

        raise Exception()

    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
        return [self.out_channel, 1, 1]

    def __call__(self, repeat: int = 1):
        return self._get_module(GlobalAvgPool())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.GlobalAvgPoolGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.GlobalAvgPoolGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    if isinstance(self.from_idx, int):
        return self.in_channels[self.from_idx]

    raise Exception()</code></pre>
</details>
</dd>
<dt id="kindle.generator.GlobalAvgPoolGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    if isinstance(self.from_idx, int):
        return self.in_channels[self.from_idx]

    raise Exception()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.GlobalAvgPoolGenerator.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: numpy.ndarray, repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute out shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
    &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
    return [self.out_channel, 1, 1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.LinearGenerator"><code class="flex name class">
<span>class <span class="ident">LinearGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear (fully connected) module generator for parsing.</p>
<p>Initailize.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Linear (fully connected) module generator for parsing.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        &#34;&#34;&#34;Initailize.&#34;&#34;&#34;
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        return self.args[0]

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
        return self.in_channels[self.from_idx]  # type: ignore

    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        &#34;&#34;&#34;Compute output shape.&#34;&#34;&#34;
        return [self.out_channel]

    def __call__(self, repeat: int = 1):
        # TODO: Apply repeat
        act = self.args[1] if len(self.args) &gt; 1 else None

        return self._get_module(
            Linear(self.in_channel, self.out_channel, activation=act)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.LinearGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.LinearGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    # error: Value of type &#34;Optional[List[int]]&#34; is not indexable
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
<dt id="kindle.generator.LinearGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    return self.args[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.LinearGenerator.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: numpy.ndarray, repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute output shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
    &#34;&#34;&#34;Compute output shape.&#34;&#34;&#34;
    return [self.out_channel]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.MaxPoolGenerator"><code class="flex name class">
<span>class <span class="ident">MaxPoolGenerator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Max pooling module generator.</p>
<p>Initialize module generator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Module arguments</dd>
<dt><strong><code>from_idx</code></strong></dt>
<dd>Module input index</dd>
<dt><strong><code>in_channels</code></strong></dt>
<dd>Number of input channel</dd>
<dt><strong><code>width_multiply</code></strong></dt>
<dd>Channel width multiply</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MaxPoolGenerator(GeneratorAbstract):
    &#34;&#34;&#34;Max pooling module generator.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def out_channel(self) -&gt; int:
        &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
        return self.in_channels[self.from_idx]  # type: ignore

    @property
    def in_channel(self) -&gt; int:
        &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
        return self.in_channels[self.from_idx]  # type: ignore

    @property
    def base_module(self) -&gt; nn.Module:
        &#34;&#34;&#34;Base module.&#34;&#34;&#34;
        return getattr(nn, f&#34;{self.name}2d&#34;)

    def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
        &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
        with torch.no_grad():
            module: nn.Module = self(repeat=repeat)
            module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
            return list(module_out.shape[-3:])

    def __call__(self, repeat: int = 1):
        module = (
            [self.base_module(*self.args) for _ in range(repeat)]
            if repeat &gt; 1
            else self.base_module(*self.args)
        )
        return self._get_module(module)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="kindle.generator.poolings.AvgPoolGenerator" href="poolings.html#kindle.generator.poolings.AvgPoolGenerator">AvgPoolGenerator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kindle.generator.MaxPoolGenerator.CHANNEL_DIVISOR"><code class="name">var <span class="ident">CHANNEL_DIVISOR</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="kindle.generator.MaxPoolGenerator.base_module"><code class="name">var <span class="ident">base_module</span> : torch.nn.modules.module.Module</code></dt>
<dd>
<div class="desc"><p>Base module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_module(self) -&gt; nn.Module:
    &#34;&#34;&#34;Base module.&#34;&#34;&#34;
    return getattr(nn, f&#34;{self.name}2d&#34;)</code></pre>
</details>
</dd>
<dt id="kindle.generator.MaxPoolGenerator.in_channel"><code class="name">var <span class="ident">in_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get in channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def in_channel(self) -&gt; int:
    &#34;&#34;&#34;Get in channel size.&#34;&#34;&#34;
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
<dt id="kindle.generator.MaxPoolGenerator.out_channel"><code class="name">var <span class="ident">out_channel</span> : int</code></dt>
<dd>
<div class="desc"><p>Get out channel size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_channel(self) -&gt; int:
    &#34;&#34;&#34;Get out channel size.&#34;&#34;&#34;
    return self.in_channels[self.from_idx]  # type: ignore</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kindle.generator.MaxPoolGenerator.compute_out_shape"><code class="name flex">
<span>def <span class="ident">compute_out_shape</span></span>(<span>self, size: numpy.ndarray, repeat: int = 1) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute out shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_out_shape(self, size: np.ndarray, repeat: int = 1) -&gt; List[int]:
    &#34;&#34;&#34;Compute out shape.&#34;&#34;&#34;
    with torch.no_grad():
        module: nn.Module = self(repeat=repeat)
        module_out: torch.Tensor = module(torch.zeros([1, *list(size)]))
        return list(module_out.shape[-3:])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kindle.generator.base_generator.GeneratorAbstract" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract">GeneratorAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="kindle.generator.base_generator.GeneratorAbstract.name" href="base_generator.html#kindle.generator.base_generator.GeneratorAbstract.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kindle.generator.ModuleGenerator"><code class="flex name class">
<span>class <span class="ident">ModuleGenerator</span></span>
<span>(</span><span>module_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Module generator class.</p>
<p>Generate module based on the {module_name}</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>{module_name}Generator class must have been implemented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModuleGenerator:
    &#34;&#34;&#34;Module generator class.&#34;&#34;&#34;

    def __init__(self, module_name: str):
        &#34;&#34;&#34;Generate module based on the {module_name}

        Args:
            module_name: {module_name}Generator class must have been implemented.
        &#34;&#34;&#34;
        self.module_name = module_name

    def __call__(self, *args, **kwargs):
        # replace getattr
        return getattr(
            __import__(&#34;kindle.generator&#34;, fromlist=[&#34;&#34;]),
            f&#34;{self.module_name}Generator&#34;,
        )(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kindle" href="../index.html">kindle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="kindle.generator.base_generator" href="base_generator.html">kindle.generator.base_generator</a></code></li>
<li><code><a title="kindle.generator.bottleneck" href="bottleneck.html">kindle.generator.bottleneck</a></code></li>
<li><code><a title="kindle.generator.concat" href="concat.html">kindle.generator.concat</a></code></li>
<li><code><a title="kindle.generator.conv" href="conv.html">kindle.generator.conv</a></code></li>
<li><code><a title="kindle.generator.dwconv" href="dwconv.html">kindle.generator.dwconv</a></code></li>
<li><code><a title="kindle.generator.flatten" href="flatten.html">kindle.generator.flatten</a></code></li>
<li><code><a title="kindle.generator.linear" href="linear.html">kindle.generator.linear</a></code></li>
<li><code><a title="kindle.generator.poolings" href="poolings.html">kindle.generator.poolings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kindle.generator.AvgPoolGenerator" href="#kindle.generator.AvgPoolGenerator">AvgPoolGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.AvgPoolGenerator.CHANNEL_DIVISOR" href="#kindle.generator.AvgPoolGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.BottleneckGenerator" href="#kindle.generator.BottleneckGenerator">BottleneckGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.BottleneckGenerator.CHANNEL_DIVISOR" href="#kindle.generator.BottleneckGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.BottleneckGenerator.base_module" href="#kindle.generator.BottleneckGenerator.base_module">base_module</a></code></li>
<li><code><a title="kindle.generator.BottleneckGenerator.compute_out_shape" href="#kindle.generator.BottleneckGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.BottleneckGenerator.in_channel" href="#kindle.generator.BottleneckGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.BottleneckGenerator.out_channel" href="#kindle.generator.BottleneckGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.ConcatGenerator" href="#kindle.generator.ConcatGenerator">ConcatGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.ConcatGenerator.CHANNEL_DIVISOR" href="#kindle.generator.ConcatGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.ConcatGenerator.compute_out_shape" href="#kindle.generator.ConcatGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.ConcatGenerator.in_channel" href="#kindle.generator.ConcatGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.ConcatGenerator.out_channel" href="#kindle.generator.ConcatGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.ConvGenerator" href="#kindle.generator.ConvGenerator">ConvGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.ConvGenerator.CHANNEL_DIVISOR" href="#kindle.generator.ConvGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.ConvGenerator.base_module" href="#kindle.generator.ConvGenerator.base_module">base_module</a></code></li>
<li><code><a title="kindle.generator.ConvGenerator.in_channel" href="#kindle.generator.ConvGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.ConvGenerator.out_channel" href="#kindle.generator.ConvGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.DWConvGenerator" href="#kindle.generator.DWConvGenerator">DWConvGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.DWConvGenerator.CHANNEL_DIVISOR" href="#kindle.generator.DWConvGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.DWConvGenerator.base_module" href="#kindle.generator.DWConvGenerator.base_module">base_module</a></code></li>
<li><code><a title="kindle.generator.DWConvGenerator.in_channel" href="#kindle.generator.DWConvGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.DWConvGenerator.out_channel" href="#kindle.generator.DWConvGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.FlattenGenerator" href="#kindle.generator.FlattenGenerator">FlattenGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.FlattenGenerator.CHANNEL_DIVISOR" href="#kindle.generator.FlattenGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.GeneratorAbstract" href="#kindle.generator.GeneratorAbstract">GeneratorAbstract</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.GeneratorAbstract.CHANNEL_DIVISOR" href="#kindle.generator.GeneratorAbstract.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.GeneratorAbstract.compute_out_shape" href="#kindle.generator.GeneratorAbstract.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.GeneratorAbstract.in_channel" href="#kindle.generator.GeneratorAbstract.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.GeneratorAbstract.name" href="#kindle.generator.GeneratorAbstract.name">name</a></code></li>
<li><code><a title="kindle.generator.GeneratorAbstract.out_channel" href="#kindle.generator.GeneratorAbstract.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.GlobalAvgPoolGenerator" href="#kindle.generator.GlobalAvgPoolGenerator">GlobalAvgPoolGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.GlobalAvgPoolGenerator.CHANNEL_DIVISOR" href="#kindle.generator.GlobalAvgPoolGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.GlobalAvgPoolGenerator.compute_out_shape" href="#kindle.generator.GlobalAvgPoolGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.GlobalAvgPoolGenerator.in_channel" href="#kindle.generator.GlobalAvgPoolGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.GlobalAvgPoolGenerator.out_channel" href="#kindle.generator.GlobalAvgPoolGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.LinearGenerator" href="#kindle.generator.LinearGenerator">LinearGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.LinearGenerator.CHANNEL_DIVISOR" href="#kindle.generator.LinearGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.LinearGenerator.compute_out_shape" href="#kindle.generator.LinearGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.LinearGenerator.in_channel" href="#kindle.generator.LinearGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.LinearGenerator.out_channel" href="#kindle.generator.LinearGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.MaxPoolGenerator" href="#kindle.generator.MaxPoolGenerator">MaxPoolGenerator</a></code></h4>
<ul class="">
<li><code><a title="kindle.generator.MaxPoolGenerator.CHANNEL_DIVISOR" href="#kindle.generator.MaxPoolGenerator.CHANNEL_DIVISOR">CHANNEL_DIVISOR</a></code></li>
<li><code><a title="kindle.generator.MaxPoolGenerator.base_module" href="#kindle.generator.MaxPoolGenerator.base_module">base_module</a></code></li>
<li><code><a title="kindle.generator.MaxPoolGenerator.compute_out_shape" href="#kindle.generator.MaxPoolGenerator.compute_out_shape">compute_out_shape</a></code></li>
<li><code><a title="kindle.generator.MaxPoolGenerator.in_channel" href="#kindle.generator.MaxPoolGenerator.in_channel">in_channel</a></code></li>
<li><code><a title="kindle.generator.MaxPoolGenerator.out_channel" href="#kindle.generator.MaxPoolGenerator.out_channel">out_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kindle.generator.ModuleGenerator" href="#kindle.generator.ModuleGenerator">ModuleGenerator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>